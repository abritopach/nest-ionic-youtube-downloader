import { ParserServices, TSESLint } from '@typescript-eslint/experimental-utils';
export declare const createESLintRule: <TOptions extends readonly unknown[], TMessageIds extends string, TRuleListener extends TSESLint.RuleListener = TSESLint.RuleListener>({ name, meta, defaultOptions, create, }: Readonly<{
    name: string;
    meta: {
        docs: Pick<TSESLint.RuleMetaDataDocs, "category" | "description" | "recommended" | "suggestion" | "requiresTypeChecking" | "extendsBaseRule">;
    } & Pick<TSESLint.RuleMetaData<TMessageIds>, "deprecated" | "fixable" | "messages" | "type" | "replacedBy" | "schema">;
    defaultOptions: Readonly<TOptions>;
    create: (context: Readonly<TSESLint.RuleContext<TMessageIds, TOptions>>, optionsWithDefault: Readonly<TOptions>) => TRuleListener;
}>) => TSESLint.RuleModule<TMessageIds, TOptions, TRuleListener>;
declare type RequiredParserServices = {
    [k in keyof ParserServices]: Exclude<ParserServices[k], undefined>;
};
/**
 * TODO: Expose via @typescript-eslint/experimental-utils
 */
export declare function getParserServices<TMessageIds extends string, TOptions extends any[]>(context: TSESLint.RuleContext<TMessageIds, TOptions>): RequiredParserServices;
declare type NodeMaps = {
    [k in keyof Pick<ParserServices, 'esTreeNodeToTSNodeMap' | 'tsNodeToESTreeNodeMap'>]: NonNullable<ParserServices[k]>;
};
/**
 * TODO: Expose via @typescript-eslint/experimental-utils
 */
export declare function getNodeMaps<_TMessageIds extends string, _TOptions extends any[]>(context: any): NodeMaps;
export {};
